\section{Concept of Variables and Data Exchange in the \mha{}}
\label{sec:variables}

Accessibility of configuration variables\index{configuration variable}\index{variable!configuration}\index{variables} and
data exchange between plugins (processing blocks) are an important issue in the
\mha{}. In general, variable types in the \mha{} are distinguished by their
different access methods. The variable types in the \mha{} are:

\begin{itemize}
\item{\bf Configuration variables}\index{configuration variable}\index{variable!configuration}: Read and
  write accesses are possible through the \mha{} configuration language interface.
  Configuration variables are implemented as C++ classes with a public data
  member of the underlying C type.
  Configuration variables can be read and modified from ``outside'' using the 
  configuration language.
  The plugin which provides the configuration variable can use 
  the exposed data member directly.
  All accesses through the \mha{} configuration language are checked for data
  type, valid range, and access restrictions. 
  See section \ref{sec:script} (page
  \pageref{sec:script}) for details.
  
\item{\bf Monitor variables}\index{monitor variable}\index{variable!monitor}: Read access is possible
  through the \mha{} configuration language. 
  Write access is only possible from the C++ code. 
  Internally, monitor variables have a similar C++ class interface
  as configuration
  variables. See section \ref{sec:script} (page \pageref{sec:script}) for
  details.
  
\item{\bf AC variables}\index{AC variable}\index{algorithm
    communication variable}\index{variable!AC} (algorithm
    communication variables): Any C or C++ data structure can be
    shared within an \mha{} chain. Access management and name space is
    realised in \mha{} chain plugins ('mhachain' and
    'altplugs'). 
    AC variables are not available to the \mha{} configuration language interface,
    although a read-only converter plugin \verb!acmon! is available.
  
\item{\bf Runtime configuration}\index{runtime configuration}\index{configuration!runtime-}: Algorithms
  usually derive more parameters (runtime configuration)
  from the \mha{} configuration language variables. 
  When a configuration variable changes through configuration language write 
  access, then the runtime configuration has to be recomputed.  
  Plugin developers are encouraged to encapsulate the runtime configuration in 
  a C++ class, which recomputes the runtime configuration from 
  configuration variables in the constructor.
  The \mha{} supports lock-free and thread-safe replacement of the 
  runtime configuration instance.
  See the programmers reference handbook for details.
\end{itemize}

\MHAfigure[][\linewidth]{Variable types in the \mha{}}{variables}

\subsection{The \mha{} configuration language}
\label{sec:script}\index{script language}\index{\mha{} script language}\index{language}\index{configuration}\index{hierarchical configuration}\index{configuration!hierarchical}\index{configuration language}\index{\mha{} configuration language}

The \mhad{} and most of the \mha{} plugins are controlled
through the \mha{} configuration language. This language is implemented in the
MHAToolbox library. It allows hierarchical configuration similar to the
concept of \Matlab{} structures. 
Each configuration level (parser)\index{parser}
can contain items like variables or sub-parsers. Properties of any item can be
queried.  Write access to items can be connected with C++ callback functions
which makes it possible to change the configuration and state of the \mha{} 
and all plugins while the audio signal is being processed.

The \mha{} configuration language consists of line-based human-readable
text commands.
The \mha{} configuration language interpreter receives commands by
reading text files or through a TCP network stream.  
The \mha{} also provides access to the configuration language parser via
a C++ object, 
which also uses the text interface\index{text interface},
for embedding the \mha{} into other applications (e.g. Windows \mha{}
configurator GUI, \Matlab{} access).

\subsubsection{Structure of the \mha{} configuration language}

A \mha{} configuration language command has a very simple structure: Each
command consists of a left value, an operator\index{operator} and a
right value. Three operators are defined:

\index{access operator}\index{operator!access-}%
\index{query operator}\index{operator!query-}%
\index{descending operator}\index{operator!descending-}%
\begin{itemize}
\item An {\bf access operator "="} is used to set a value of a variable.
\item A {\bf query operator "?"}
  is used to query a value, type or other information of a variable or other
  nodes (with some exceptions).
\item A {\bf descending operator "."} descends into the next level of the
  hierarchical \mha{} configuration.
\end{itemize}

Each left value is the name of a parser entry. Not all operators are
available for all parser entries: A subparser supports only "?" and
".", a monitor only "?". The structure of parser entries is shown in
\figref{parserelements}. In the configuration files, \mha{} script
language commands can be split up into multiple lines similar as in
\Matlab{}: If a lines ends with "\verb!...!", the next line will be
appended. This holds not for the command prompt (e.g.\ Windows
framework, Configurator, TCP interface).

\MHAfigure[][\linewidth]{\mha{} configuration language: These C++ classes 
  (living in the namespace ``MHAParser'') can be used to implement monitor
  variables, configuration variables, and sub-hierarchies (parser\_t).
}{parserelements}

The \mha{} configuration language features strong static typing, the data type
of a variable is defined by the plugin that implements this variable.
Many configuration language commands like write access ("=") to variables can
be connected to C++ callbacks by the plugin developer.

\subsubsection{Query commands}

\index{query command}\index{command!query}%
The query operator without any right value shows the contents of a parser item
in a human readable way. By passing a right value to the query operator, the
type of query can be influenced. A query operator together with its right
value forms a {\em query command}. Valid query commands
are:
\index{\verb.?.}%
\index{\verb.?cmds.}%
\index{\verb.?val.}%
\index{\verb.?type.}%
\index{\verb.?perm.}%
\index{\verb.?range.}%
\index{\verb.?subst.}%
\index{\verb.?entries.}%

\begin{itemize}
\item {\bf ?}: Show contents of a parser element.
\item {\bf ?cmds}: Show a list of all query commands for this element.
\item {\bf ?help}: Show the detailed description of an element.
\item {\bf ?val}: Return the value of an element.
\item {\bf ?type}: Return the data type of an element.
\item {\bf ?perm}: Return the access rights for an element.
\item {\bf ?range}: Return the range of valid values for this variable.
\item {\bf ?subst}: Show all variable substitutions applied to this node.
\item {\bf ?entries}: Show a list of all entries in this node.
\end{itemize}

Special query commands are:
\index{\verb.?save.}%
\index{\verb.?saveshort.}%
\index{\verb.?savemons.}%
\index{\verb.?read.}%

\begin{itemize}
\item {\bf ?save:filename}: Save the contents of this node into the
text file "filename", complete with element description comments.
\item {\bf ?saveshort:filename}: Save the contents of this node into the
text file "filename", without additional comments or blank lines.
\item {\bf ?savemons:filename}: Save the contents of all monitor variables to
  the file 'filename'.
\item {\bf ?read:filename}: Read the file "filename" into the current
parser node.
\end{itemize}

\subsubsection{Multidimensional variables}%
\index{multidimensional variable}%
\index{variable!multidimensional}%

The \mha{} configuration language supports vectors and matrices in a way similar
to the \Matlab{} notation: Vectors are put into squared brackets, with
the items separated by withespace (\Matlab{} row vectors). Matrices are
noted as vectors of vectors, with each vector separated by a semicolon
from the other vectors:

\begin{verbatim}
vector = [1.0 2.7 4]
matrix = [[1 2 3];[4 5 6]]
\end{verbatim}

Vectors with real values (vector<float>, library class
\verb!vfloat_t!) support also the special notation
\verb!min:increment:max!. A mixture of explicit and incremential
notation is allowed. The vector is internally expanded and will return
the explicit notation on read:

\begin{verbatim}
vector = [1.0 1.7 2.1:1.1:5]
\end{verbatim}

This will be expanded as:

\begin{verbatim}
vector = [1.0 1.7 2.1 3.2 4.3]
\end{verbatim}

\subsubsection{Complex variables}%
\index{complex variable}%
\index{variable!complex}%

Variables with complex values are notated in parenthesis as a sum of
real and imaginary part. Pure real values can be noted without
parenthesis:

\begin{verbatim}
complex = (1.3 + 2.7i)
vcomplex = [(1.3 + 2.7i) (2.0 - 1.1i) 6.3]
\end{verbatim}

\subsubsection{Text variables}\index{text variable}\index{variable!text}

Strings in the \mha{} configuration language can contain any characters. Special
characters do not have to be quoted; quote characters are treated
literally. Leading and trailing whitespace of strings is automatically
removed. Vector elements in string vectors are separated by a single
space character. This means that vector elements
(\verb!vstring_t!, \verb!kw_t!) can not contain spaces.

\begin{verbatim}
string =  This is a valid text string.
samestr=This is a valid text string.
strvec = [pears bananas green_apples]
\end{verbatim}

\subsubsection{Variable ranges}\index{variable range}\index{range}

Numeric variables can have a restricted range, the value of keyword list 
variables is always restricted to one of the keywords. New values are checked 
against this range when the variable is changed through the \mha{} configuration 
language interface. For numeric variables, the range can be 
$[x_{min},x_{max}]$ (boundaries included), $]x_{min},x_{max}[$
(boundaries excluded) or a mixed version of both. If $x_{min}$ or
$x_{max}$ are omitted then the variable will not have a lower or
upper boundary.

For keyword list variables, the range is simply a space separated list of valid
entries.

\subsubsection{Variable Substitution and Environment
  Variables}\index{substitution}\index{environment variable}\index{variable!environment}

Each node in the \mha{} configuration tree can define a set of text
substitutions.  The pattern to be replaced has the form "\$[VARNAME]",
where VARNAME can be any text. Any occurrence of this pattern is
replaced. The set of substitutions can be queried with the "?subst"
query command. Replacements can be activated with the "?addsubst"
query command in the style
\verb!?addsubst:<VARNAME> <REPLACEMENT>!. Each parser node has its own
set of text substitutions, which is not inherited by children parser
nodes.

Environment variables can be used in the \mha{} configuration language in the form
"\$\{VARNAME\}", where VARNAME is the name of an environment variable. Each
occurrence of \$\{VARNAME\} is replaced by its contents before interpreting the
\mha{} configuration language, i.e.\ the left hand side or even operators can be part of
the substitution.

\subsection{Communication between \mha{} Plugins}\index{AC variable}\index{variable!AC}\index{communication}

Interaction of algorithms is a major issue in hearing aid
development. In order to systematically analyse and control
interaction problems, the \mha{} chain plugins 'mhachain' and
'concurrentchains' provide a mechanism for sharing parameters and
states between algorithms. Any algorithm plugin can register selected
algorithm communication (AC) variables (any data segment) to be public
within one signal processing
chain. Other algorithms within the same processing chain can read and
modify these AC variables. AC variables are accessed by name. Type and
dimension are checked on each access. This concept does not only
provide analysis of interaction aspects but also modular combination
of signal processing strategies, e.g.\ separation of noise estimators
and noise reduction strategies in different logical processing
stages. A detailed description of the programming interface can be
found in the Programmers Reference Handbook.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "MHA_manual"
%%% End: 
