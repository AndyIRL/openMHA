\section{Advanced example configurations and framework scenarios}%
\label{sec:advancedex}%

\subsection{An algorithm which operates on the down-sampled time signal}%
\index{Down-sampling}%
\index{Re-sampling}%

In this section, the same algorithm as in section \ref{sec:linha} is
configured, but is designed to run on the down-sampled signal. We
assume a framework which runs at 48 kHz. The algorithm is intended to
work with 16 kHz sampling rate, i.e.\ down-sampling by a factor 3 is
configured. Please note that the down- and up-sampling modules support
only integer sampling rate ratios, for other ratios use a combination
of up- and down-sampling.

The original algorithm of section \ref{sec:linha} has a FFT length of
192 samples. The new FFT length will be 64 samples to achieve equal
frequency resolution. In the original algorithm, the window length is
2/3 of the FFT length, with 50\% window shift. Thus, the new window
length will be 40 samples (avoid odd window lengths for 50\% window
shift) and the window shift 20 samples. The down-sampling plugin {\tt
  downsample} then requires 60 samples fragment size at its input. If
your framework does not support 60 samples fragment size (e.g.\ when
using JACK), please insert the double buffer layer {\tt dbasync} for
low-delay processing or {\tt db} otherwise.

Again, we create a linear hearing aid. To add re-sampling, an extra
layer is inserted between the MHA framework and the overlap-add
plugin:
\begin{verbatim}
#[MHAVersion 4.4]
algos = [downsample overlapadd upsample]
\end{verbatim}
The downsample plugin and the upsample plugin can use the same
configuration of their anti-aliasing filters:
\begin{verbatim}
downsample.ratio = 3
downsample.antialias.A = [1 -0.9658 0.5826 -0.106]
downsample.antialias.B = [0.0639 0.1916 0.1916 0.0639]
upsample.ratio = 3
upsample.antialias.A = [1 -0.9658 0.5826 -0.106]
upsample.antialias.B = [0.0639 0.1916 0.1916 0.0639]
\end{verbatim}
Now, we have to configure the FFT and the equaliser in a similar way
as before, only the overlap-add parameter are adapted to the new
sampling rate and block size.
\begin{verbatim}
overlapadd.fftlen = 64
overlapadd.wnd.len = 40
overlapadd.plugname = mhachain
overlapadd.plug.algos = [...
  rmslevel:Lin ...
  fftfilterbank gain combinechannels ...
  rmslevel:Lout ...
]

overlapadd.plug.fftfilterbank.fscale = bark
overlapadd.plug.fftfilterbank.ovltype = hanning
overlapadd.plug.fftfilterbank.plateau = 0
overlapadd.plug.fftfilterbank.ftype = center
overlapadd.plug.fftfilterbank.f = [250 500 1000 2000 4000]
overlapadd.plug.gain.min = -16
overlapadd.plug.gain.max = 32
overlapadd.plug.gain.gains = [0 5 10 15 10 2 7 9 12 16]
overlapadd.plug.combinechannels.name = fftfilterbank_nchannels
overlapadd.plug.combinechannels.gains = []
\end{verbatim}
This configuration can be found in file \verb!mhaex2.cfg! in the
\verb!cfg! directory of your distribution.

Please make sure that the framework provides a fragment size of 60
samples to reach a window shift of 50\%. An example framework
configuration for the \mhad{} running with JACK can be found in file
\verb!fwex2.cfg! in the \verb!cfg! directory.

\subsection{Configuring and calibrating a low-delay real-time hearing aid}

For a linear hearing aid it is not necessary to have knowledge about
absolute levels, only the acoustic gain of the system should be
determined.
%
For non-linear hearing aids, a calibration to absolute levels is required.
%
The MHA provides a plugin for calibration, {\tt transducers}.
%
If this plugin is used properly, all other plugins within 'transducers'
can interpret the input signal as free field sound pressure level in
Pascal.
%
The level meter {\tt rmslevel} and {\tt fftfbpow} can show the current
sound pressure level in dB SPL.
%
In this example, a free-field calibrated (linear) hearing aid will be
configured.
%
The algorithm configuration of the first example is used (see file
\verb!mhaex1.cfg!), the calibration plugin is configured in a new
framework configuration file \verb!fwex3.cfg!.
%
The beginning is the same as before:
\begin{verbatim}
#[MHAVersion 4.4]
nchannels_in = 2
fragsize = 64
srate = 48000
iolib = MHAIOJack
io.con_in = [alsa_pcm:capture_1 alsa_pcm:capture_2]
io.con_out = [alsa_pcm:playback_1 alsa_pcm:playback_2]
\end{verbatim}
Now the calibration module is used as top-level signal processing
plugin.
%
\begin{verbatim}
mhalib = transducers
mha.calib_in.fir = [...
  [1]; ...
  [1] ...
]
mha.calib_in.peaklevel = [115.6 118]
mha.calib_out.peaklevel = [121 112]
mha.calib_out.fir = [...
  [1]; ...
  [1] ...
]
\end{verbatim}
The overlap add method is loaded as a sub-plugin into the calibration
method, i.e., all levels within the overlap add are calibrated to
free-field SPL.
\begin{verbatim}
mha.pluglib = overlapadd
mha.plug?read:mhaex1.cfg
\end{verbatim}

\subsection{Splitting of analysis and filter path}%
\label{sec:split_analysis}%
\index{analysis path}%
\index{filter path}%

In many cases, signal analysis algorithms require a longer integration
over time than the actual signal filter methods.
%
In such situations, a splitting of analysis path and filter path is
desirable to reduce the signal delay in the filter path.
%
Additionally, asynchronous processing allows better distribution of
processor ressources on standard operating systems.
%
Such a processing can be realised with the use of the plugin
{\tt analysispath}.

An example configuration for a setup with asynchronous signal analysis
can be found in the file 'fwex\_analysispath.cfg' in the 'cfg'
directory of this distribution.
%
This file will be explained here.
%
The first lines are the general audio parameters like sampling rate,
fragment size and number of input channels, and a configuration of the
audio backbone.
\begin{verbatim}
#[MHAVersion 4.4]
nchannels_in = 2
fragsize = 64
srate = 48000
iolib = MHAIOJack
io.name = MHA
io.con_in = [alsa_pcm:capture_1 alsa_pcm:capture_2]
io.con_out = [alsa_pcm:playback_1 alsa_pcm:playback_2]
\end{verbatim}
As a processing library, the level calibration library will be used,
to allow a calibration of the system.
%
In this example, only the broadband calibration values are used.
%
A single chain is loaded into the calibrated system.
\begin{verbatim}
mhalib = transducers
mha.pluglib = mhachain
mha.calib_in.peaklevel = [115.599998 118]
mha.calib_out.peaklevel = [121 112]
\end{verbatim}
The algorithms of this processing chain will be the split-up point,
realised by the 'analysispath' plugin, and the filter algorithm,
symbolised by the 'acmon' AC variable monitor plugin.
%
The configuration of 'analysispath' determines the signal analysis
path.
%
Here, a chain is used; alternativly it is possible to use a single
plugin for signal analysis.
%
The signal analysis is symbolized by a simple level meter.

\begin{verbatim}
mha.plug.algos = [analysispath acmon:filter]
mha.plug.analysispath.plugname = mhachain
mha.plug.analysispath.plug.algos = [rmslevel]
\end{verbatim}
In the next lines, the fragment size of the analysis path is
configured. The output of the analysis path is discarded.  The input
has a non-blocking ring buffer, here with a length of 10 analysis
fragments. If this ring buffer is full when new data should be
written, the new audio data is discarded. The analysis thread
scheduler can be configured to run with real-time priority (if
supported by the system).
\begin{verbatim}
mha.plug.analysispath.fragsize = 48000
mha.plug.analysispath.fifolen = 10
mha.plug.analysispath.priority = -1
\end{verbatim}
The results of the analysis path should be stored as AC variables. The
complete AC space or a subset as in this example will be copied to the
filter path as soon as available (please note that a copy of the
default values is created in the prepare callback; only variables can
be shared which are available in the prepare callback and do not
change their size while processing).
\begin{verbatim}
mha.plug.analysispath.acvars = [rmslevel_level_db]
\end{verbatim}
In this example, the analysis path estimates the input level once in
every second, while the filter path has a fragment size of only 1.33
ms, i.e., a total delay of 4 ms.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "MHA_manual"
%%% End: 

% LocalWords:  plugin plugins FFT MHAVersion mha cfg transducers mhaex fwex mhalib
