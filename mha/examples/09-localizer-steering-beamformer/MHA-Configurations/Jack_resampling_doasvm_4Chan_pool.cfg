srate = 48000
nchannels_in = 2
fragsize = 480

# Audio IO library to use.
iolib = MHAIOJack
io.con_in = [system:capture_1 system:capture_2]
io.con_out = [system:playback_7 system:playback_8]

mhalib = resampling

mha.srate = 16000
mha.fragsize = 160

mha.plugin_name = mhachain:chain

mha.chain.algos = [route:in addsndfile:mixed route:doa_1_2 doasvm_feature_extraction:gcc_1_2 route:doa_1_3 doasvm_feature_extraction:gcc_1_3 route:doa_1_4 doasvm_feature_extraction:gcc_1_4 route:doa_2_3 doasvm_feature_extraction:gcc_2_3 route:doa_2_4 doasvm_feature_extraction:gcc_2_4 route:doa_3_4 doasvm_feature_extraction:gcc_3_4 acConcat_wave:concat doasvm_classification:svm acPooling_wave:pool acsave:doasvm_save acmon:doasvm_mon route:all route:out]

# make 6 channels out of 2
mha.chain.in.out = [:0 :1 :0 :1]

# configure the sound file to be processed
mha.chain.mixed.path = ../Data/
mha.chain.mixed.filename = SPwHA_M2M3_az-150.wav

mha.chain.mixed.loop = yes
mha.chain.mixed.level = 60
mha.chain.mixed.levelmode = rms
mha.chain.mixed.channels = [0 1 2 3]
mha.chain.mixed.mode = replace

# configure doasvm_feature_extraction plugins, which compute the GCC matrices
mha.chain.gcc_1_2.fftlen = 160
mha.chain.gcc_1_2.nupsample = 4
mha.chain.gcc_1_2.max_lag = 20
mha.chain.gcc_1_2.vGCC_name = vGCC_ac_1

mha.chain.gcc_1_3.fftlen = 160
mha.chain.gcc_1_3.nupsample = 4
mha.chain.gcc_1_3.max_lag = 2
mha.chain.gcc_1_3.vGCC_name = vGCC_ac_2

mha.chain.gcc_1_4.fftlen = 160
mha.chain.gcc_1_4.nupsample = 4
mha.chain.gcc_1_4.max_lag = 20
mha.chain.gcc_1_4.vGCC_name = vGCC_ac_3

mha.chain.gcc_2_3.fftlen = 160
mha.chain.gcc_2_3.nupsample = 4
mha.chain.gcc_2_3.max_lag = 20
mha.chain.gcc_2_3.vGCC_name = vGCC_ac_4

mha.chain.gcc_2_4.fftlen = 160
mha.chain.gcc_2_4.nupsample = 4
mha.chain.gcc_2_4.max_lag = 2
mha.chain.gcc_2_4.vGCC_name = vGCC_ac_5

mha.chain.gcc_3_4.fftlen = 160
mha.chain.gcc_3_4.nupsample = 4
mha.chain.gcc_3_4.max_lag = 20
mha.chain.gcc_3_4.vGCC_name = vGCC_ac_6

# configure route plugins for redirecting the corresponding channel pair to the doasvm_feature_extraction plugins
mha.chain.doa_1_2.out = [:1 :0] 				# channels 2, 1
mha.chain.doa_1_2.ac = [:2 :3]	 				# channels 3, 4

mha.chain.doa_1_3.out = [doa_1_2:0 :1]				# channels 3, 1
mha.chain.doa_1_3.ac = [:0 doa_1_2:1]				# channels 2, 4

mha.chain.doa_1_4.out = [doa_1_3:1 :1]				# channels 4, 1
mha.chain.doa_1_4.ac = [doa_1_3:0 :0]				# channels 2, 3

mha.chain.doa_2_3.out = [doa_1_4:1 doa_1_4:0]			# channels 3, 2
mha.chain.doa_2_3.ac = [:1 :0]					# channels 1, 4

mha.chain.doa_2_4.out = [doa_2_3:1 :1]				# channels 4, 2
mha.chain.doa_2_4.ac = [doa_2_3:0 :0]				# channels 1, 3

mha.chain.doa_3_4.out = [:0 doa_2_4:1]				# channels 4, 3
mha.chain.doa_3_4.ac = [doa_2_4:0 :1]				# channels 1, 2

# merge all channels for signal processing
mha.chain.all.out = [doa_3_4:0 doa_3_4:1 :1 :0]

# concatenate all pairwise gcc vectors into one big vector
mha.chain.concat.num_AC = 6
mha.chain.concat.prefix_names_AC = vGCC_ac
mha.chain.concat.samples_AC = [161 17 161 161 17 161]
mha.chain.concat.name_conAC = vGCC_con_ac

# configure doasvm_classification plugin by loading the SVM parameters
mha.chain.svm?read:../DOA-SVM/matrices_4channel_front-rear_bte.cfg
mha.chain.svm.vGCC_name = vGCC_con_ac


mha.chain.pool.p_name = p
mha.chain.pool.pool_name = pool
mha.chain.pool.max_pool_ind_name = pool_max
mha.chain.pool.numsamples = 73
mha.chain.pool.pooling_wndlen = 300
mha.chain.pool.pooling_type = mean
mha.chain.pool.upper_threshold = 0.1
mha.chain.pool.neighbourhood = 4
mha.chain.pool.alpha = 0


mha.chain.doasvm_save.name = ../MHA-Configurations/4channel_doasvm_acsave.mat
mha.chain.doasvm_save.fileformat = mat4
mha.chain.doasvm_save.reclen = 30
mha.chain.doasvm_save.vars = [p p_max pool pool_max vGCC_ac_1 vGCC_ac_2 vGCC_ac_3 vGCC_ac_4 vGCC_ac_5 vGCC_ac_6 vGCC_con_ac]


#configure route:out
mha.chain.out.out = [:0 :1]

#run the configuration
cmd = start
